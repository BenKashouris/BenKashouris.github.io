---
layout: default
title: "An Introduction to Diffie–Hellman"
date: 2025-11-23
author: "Ben Kashouris"
image: /assets/images/key_outline.png
center_content: true
description: An Intro to Diffie–Hellman for Mathematics Students
---

## What is a Diffie–Hellman key exchange and what is it used for?
Diffie–Hellman is a cryptographic protocol for the production of a shared secret between two parties. Let's say two people, Alice and Bob, want to communicate securely. A reasonable first step is that they might want to start with a shared secret because they can use this secret with their communications to make them unreadable. At the most basic level, this might be a Vernam cipher, where we bitwise XOR our shared secret with any message. In reality, we use something like AES. To learn more about this, research private key encryption.

## The Discrete Log Problem
Diffie–Hellman relies on the discrete log problem, which we introduce:

$$
\begin{aligned}
& \text{Calculating } z = g^k \bmod p\text{ is easy, but calculating } k \text{ given } z \text{ is hard.} \\
& \text{Formally, calculating } z \text{ can be done in } \mathcal{O}(\log k) \text{ time.} \\
& \text{However, there exists no known polynomial-time algorithm to calculate } k \text{ given } z \text{ and } g.
\end{aligned}
$$

### Constructive proof of computing $$g^k$$ in $$\mathcal{O}(\log k)$$
We can constructively prove that there is an $$\mathcal{O}(\log k)$$ algorithm for calculating $$g^k$$ by making use of the square-and-multiply algorithm (sometimes also called exponentiation by squaring). It works by expressing $$k$$ in binary and taking nested powers.  
This relies on two index laws:  

$$
(g^{(k_1 k_2 \cdots k_n)})^2 = g^{(k_1 k_2 \cdots k_n 0)}
$$  

$$
(g^{(k_1 k_2 \cdots k_n 0)}) \cdot g = g^{(k_1 k_2 \cdots k_n 1)}
$$  

The idea of the algorithm is that we have the ability to left-shift the exponent and to add a 1 to the exponent, and we use these operations to reconstruct the power we want from right to left.  
This method performs at most one multiplication and one squaring per bit of $$n$$.  
Since $$k$$ has $$\lfloor \log_2 k \rfloor$$ bits, we obtain an $$\mathcal{O}(\log k)$$ algorithm.  
As a side point, in cryptographic applications we carry out all operations modulo some large prime, which keeps our memory usage manageable.  
If you would like to read more about this algorithm, I suggest my article on Fast Fibonacci Calculations, which uses this algorithm to calculate the $$n$$-th Fibonacci number. It is available [here](Fast_Fibonacci.html).

### But why is the reverse hard?
The real reason is that we do not have a (classically computable) algorithm that runs fast enough.  

On a more intuitive level, if we graph the continuous exponential (which is easy to reverse) versus the discrete exponential (which is hard to reverse), we can see the problem:

![Graph showing the difference between the continuous and discrete exponential](/assets/images/discrete_exponential.png)

We can observe how the smooth, continuous growth of the exponential function on the left contrasts with the seemingly random jumps on the right. The modular operation destroys the smooth structure, removing some of the tools like Taylor series that we may use in the continuous setting to form logarithms.

## Performing a key exchange with the discrete log
To perform the key exchange, we follow the procedure below:

![Graph the procedure for a Diffie–Hellman Key Exchange](/assets/images/key_exchanges.png)

By the end of the procedure, both parties have $$g^{ab}$$, but an outside observer would have to solve at least one discrete log problem to calculate this number since they never have access to $$a$$ or $$b$$, assuming Alice and Bob know they are definitely talking to each other.


## Okay, but how do we choose $$p$$ and $$g$$?

To answer this, we need to take a step back and formalize what is going on.

We have been working with multiplication modulo $$p$$, so we are working in the group

$$(\mathbb{Z}/p\mathbb{Z})^{\times}.$$

If $$p$$ is prime, then this group is cyclic and has order $$p - 1$$. If $$p$$ is large, then the search space for brute-forcing the discrete logarithm problem (DLP) is large.

However, we can immediately observe an important fact: the DLP is only as hard as the DLP in the subgroup generated by $$g$$, since

$$
g^{a} = g^{\,a \bmod \operatorname{ord}(g)}.
$$

From these two facts, a potential problem emerges. If $$p$$ is prime, then $$p - 1$$ is *not* prime (ignoring the trivial case $$p = 3$$, which is far too small to be useful in practice).

We can therefore factor the group order as

$$
\left|(\mathbb{Z}/p\mathbb{Z})^{\times}\right|
= p - 1
= p_1^{a_1} \, p_2^{a_2} \cdots p_n^{a_n}.
$$

Since the group is cyclic, we know that the following isomorphism exists:

$$
(\mathbb{Z}/p\mathbb{Z})^{\times}
\cong C_{\,p-1}
\cong C_{p_1^{a_1}} \times C_{p_2^{a_2}} \times \cdots \times C_{p_n^{a_n}}.
$$

An explicit isomorphism can be given by

$$
\varphi:\ \alpha^{k} \longmapsto (\alpha_1^{k}, \alpha_2^{k}, \ldots, \alpha_n^{k}),
\quad \text{where} \quad
\alpha_i = \alpha^{\frac{p-1}{p_i^{a_i}}},
\quad \text{and} \quad
\langle \alpha \rangle = (\mathbb{Z}/p\mathbb{Z})^{\times}.
$$ (see footnote 1)

Under this decomposition, we can rewrite the discrete logarithm problem as a collection of smaller problems:

$$
g^{m} = h
\;\Longleftrightarrow\;
(g_1^{m}, g_2^{m}, \ldots, g_n^{m})
=
(h_1, h_2, \ldots, h_n).
$$

Each element $$g_i$$ has order at most $$p_i^{a_i}$$, since

$$
g_i^{\,p_i^{a_i}} = g^{\,p-1} = e.
$$

Thus, each subproblem lives in a subgroup of order at most $$p_i^{a_i}$$. If these orders are small enough, the discrete logarithm problem in each subgroup becomes tractable.

Once the discrete logarithm is solved in each component, we obtain a system of linear congruences for $$m$$.

$$
\begin{cases}
m \equiv m_1 \pmod{p_1^{a_1}}, \\
m \equiv m_2 \pmod{p_2^{a_2}}, \\
\vdots \\
m \equiv m_n \pmod{p_n^{a_n}}.
\end{cases}
$$

This system can be efficiently solved using the Chinese Remainder Theorem, allowing us to recover the original discrete logarithm solution. 

This attack is known as the Pohlig–Hellman algorithm.

---

## So how do we choose $$p$$ and $$g$$?

If we are clever with our choice of $$p$$, this issue becomes much easier to manage. <br>
If we choose, $$p = 2q + 1,$$ where $$q$$ is a large prime. <br> 
Then the order of the group is $$|(\mathbb{Z}/p\mathbb{Z})^{\times}| = 2q.$$<br>
The only divisors of $$2q$$ are
$$
1, \; 2, \; q, \; 2q
$$ so by Lagrange’s Theorem, the only proper subgroups therefore have order $$2$$ or $$q$$. <br>
The elements of order $$1$$ and $$2$$ are precisely $$1$$ and $$-1$$. By avoiding these values when choosing $$g$$, we ensure that $$g$$ generates a subgroup of order $$q$$.<br>
In practice, we typically choose $$g = 2$$ and verify that $$g^2 \not\equiv 1 \pmod{p}$$ and $$g^q \not\equiv 1 \pmod{p}$$, ensuring $$g$$ generates the full subgroup of order $$q$$. <br>
As a result, any attacker is forced to solve the discrete logarithm problem in a group of size at least $$q$$. For sufficiently large $$q$$, this makes the Pohlig–Hellman attack infeasible and restores the intended security of Diffie–Hellman.

 
## Best known attacks   
One of the most powerful attacks on the discrete logarithm problem (DLP) is known as the baby-step giant-step algorithm.  <br>
We start by reminding ourselves of the DLP: <br> 
Given $$g, h, p$$, find $$x$$ such that $$g^x \equiv h \pmod{p}, \quad \text{where } \langle g \rangle = (\mathbb{Z}/p\mathbb{Z})^\times.$$

We write  $$x = im - j$$ for some $$i \in \mathbb{Z}$$ and $$0 \le j < m$$. <br>

We perform two steps in the algorithm a Baby step, then a Giant step. <br>
1. <u>Baby step</u> <br>
We compute $$g^j$$ for $$j = 0, 1, ..., m-1$$ <br>
We store $$g^j$$ in a hash table with key $$j$$ for $$O(1)$$ access.
2. <u>Giant step</u><br>
We compute $$h(g^{-m})^i$$ for $$i = 0, 1, ..., \lceil p/m \rceil$$ <br>
We check whether this matches a value in the baby step.

If we get a match then $$g^{im} \equiv h \cdot g^j \pmod{p} \implies g^{im - j} \equiv h \pmod{p}$$. <br>
So we have solved the DLP.

In terms of time complexity we perform $$m$$ steps in the baby step then $$p/m$$ steps in the giant step, so the total number of steps is $$m + p/m$$. <br>
We want to minimize the number of steps which happens at $$m = \sqrt{p}$$. <br>
Since we store $$m$$ numbers in the baby step we have a space complexity of $$\mathcal{O}(m) = \mathcal{O}(\sqrt{p})$$. <br>
We also have a time complexity of $$\mathcal{O}(\sqrt{p})$$.

This is a very fast algorithm for solving the discrete log problem, but unfortunately the space complexity of $$\mathcal{O}(\sqrt{p})$$ is far too high to be used in practice when we are dealing with such large p. <br>
There is an algorithm called Pollard's Rho, which replaces deterministic behavior with a probabilistic approach. It achieves the same time complexity as the baby-step giant-step algorithm while using only $$\mathcal{O}(1)$$ space, but we will not cover it here.


## Generalisation
As a final point, Diffie-Hellman does not only work in $$(\mathbb{Z}/p\mathbb{Z})^\times$$; it can be implemented in any finite cyclic group where the discrete logarithm problem is hard, such as elliptic curve groups. Elliptic curve groups have become increasingly popular because they are resistant to extremely fast attacks on $$(\mathbb{Z}/p\mathbb{Z})^\times$$, such as the index calculus method, which runs in subexponential time.

All commonly deployed Diffie–Hellman key exchange schemes, including those based on $$(\mathbb{Z}/p\mathbb{Z})^\times$$ and elliptic curve groups, are vulnerable to Shor’s algorithm, a quantum algorithm that solves the discrete logarithm problem in $$\mathcal{O}((\log n)^3)$$ time. This threat has motivated extensive research into post-quantum cryptographic schemes, such as lattice-based cryptography, which are believed to be resistant to known quantum attacks. I hope to publish another article on this topic soon!

#### Footnote 1
We want to show that $$\varphi: (\mathbb{Z}/p\mathbb{Z})^{\times}  \to C_{p_1^{a_1}} \times C_{p_2^{a_2}} \times \cdots \times C_{p_n^{a_n}}; \alpha^{k} \longmapsto (\alpha_1^{k}, \alpha_2^{k}, \ldots, \alpha_n^{k})$$.    
Where $$\alpha_i = \alpha^{\frac{p-1}{p_i^{a_i}}}$$ and $$p-1 = p_1^{a_1} \cdot p_2^{a_2} \dots p_n^{a_n}$$ is the prime factorization of p-1 is a group isomorphism.  

We first show that $$\varphi$$ is a group homomorphism.
<span style="display: inline-block; margin-left: 2rem;">
    Let $$a, b \in (\mathbb{Z}/p\mathbb{Z})^\times$$, since $$(\mathbb{Z}/p\mathbb{Z})^\times$$ is cyclic $$\exists k_1, k_2 \in \mathbb{Z}$$ such that $$a=\alpha^{k_1}, b=\alpha^{k_2}$$.  
    Then $$\varphi(a \cdot b) = \varphi(\alpha ^ {k_1} \cdot \alpha ^ {k_2}) = \varphi(\alpha ^ {k_1 + k_2}) = (\alpha_1^{k_1 + k_2}, \alpha_2^{k_1 + k_2}, \ldots, \alpha_n^{k_1 + k_2})$$  
    And $$\varphi(a) \cdot \varphi(b) = (\alpha_1^{k_1}, \alpha_2^{k_1}, \ldots, \alpha_n^{k_1}) \cdot (\alpha_1^{k_2}, \alpha_2^{k_2}, \ldots, \alpha_n^{k_2}) = (\alpha_1^{k_1 + k_2}, \alpha_2^{k_1 + k_2}, \ldots, \alpha_n^{k_1 + k_2})$$  
    So  $$\varphi(a \cdot b) = \varphi(a) \cdot \varphi(b)$$ so $$\varphi$$ is a group homomorphism.
</span>

We now show that the homomorphism is injective, by computing $$\ker(\varphi)$$. 
<span style="display: inline-block; margin-left: 2rem;">
    Let $$a \in (\mathbb{Z}/p\mathbb{Z})^\times$$ be such that $$\varphi(a) = (1, \dots, 1)$$.  
    Write $$a = \alpha^k$$ for some $$k \in \mathbb{Z}$$.   
    Then $$\forall i, \ a_i^k \equiv 1 \implies \big(\alpha^{\frac{p-1}{p_i^{a_i}}}\big)^k = \alpha^{\,k\frac{p-1}{p_i^{a_i}}} \equiv 1 \pmod{p}$$  
    $$\implies \operatorname{ord}(\alpha) = p-1 \;\;\big|\;\; \frac{k(p-1)}{p_i^{a_i}} = (p-1)\frac{k}{p_i^{a_i}}$$     
    $$\implies \frac{k}{(p_i^{a_i})} \in \mathbb{Z} \implies (p_i^{a_i}) \mid k, \forall i$$  
    Therefore $$\operatorname{lcm\bigl(p_1^{a_1}, p_2^{a_2}, \dots, p_n^{a_n}\bigr)} \mid k$$     
    Recalling that $$\operatorname{lcm\bigl(p_1^{a_1}, p_2^{a_2}, \dots, p_n^{a_n}\bigr)} = p-1$$, we conclude that $$k \equiv 0 \bmod\ p-1$$  
    and hence $$a = \alpha ^ k = 1 \implies \ker(\varphi) = \{1\}$$.  
    Thus $$\ker(\varphi)$$ is injective.
</span>

Finally $$\varphi$$ is a isomorphism  
<span style="display: inline-block; margin-left: 2rem;">
    Since $$|(\mathbb{Z}/p\mathbb{Z})^{\times}| = p-1$$ and $$|C_{p_1^{a_1}} \times C_{p_2^{a_2}} \times \cdots \times C_{p_n^{a_n}}| = \prod_{i=1}^n p_i^{a_i} = p - 1$$. <br>
    The domain and codomain have the same finite cardinality. <br>
    And by pigeon-hole, an injective homomorphism between finite groups of the same order is surjective, hence bijective.
</span>

Therefore, $$\varphi$$ is an isomorphism. $$\square$$
